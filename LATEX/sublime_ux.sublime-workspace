{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"allocat",
				"allocation_of_values_to_team_data"
			],
			[
				"foot",
				"football_data_array"
			],
			[
				"match",
				"matchescount"
			],
			[
				"write",
				"write_teamname_into_array"
			],
			[
				"foo",
				"football_data_array"
			],
			[
				"mat",
				"matches"
			],
			[
				"fo",
				"football_data_array"
			],
			[
				"num",
				"number_of_matches"
			],
			[
				"print",
				"print_match"
			],
			[
				"ma",
				"matchdatapointer"
			],
			[
				"fot",
				"football_data_array"
			],
			[
				"footbal",
				"football_data_array"
			],
			[
				"football_d",
				"football_data_array"
			],
			[
				"football",
				"football_data"
			],
			[
				"footb",
				"football_data_array"
			],
			[
				"spec",
				"spectators"
			],
			[
				"gen",
				"general_help"
			],
			[
				"general",
				"general_FAQ"
			],
			[
				"hel",
				"help_options"
			],
			[
				"help",
				"help_options"
			],
			[
				"In",
				"InputString"
			],
			[
				"rand",
				"randforret"
			],
			[
				"ra",
				"randhovedret"
			],
			[
				"g",
				"g_or_h"
			],
			[
				"timer",
				"timer_minutter_sekunder"
			],
			[
				"co",
				"convertrubler"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "\\section{ViewPort}\\label{ViewPort}\n\n",
			"settings":
			{
				"buffer_size": 36,
				"line_ending": "Windows"
			}
		},
		{
			"file": "sections/Implementation/Viewport.tex",
			"settings":
			{
				"buffer_size": 6647,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "\\section{Pathfinder}\\label{Pathfinder}\nFor at forklare implementationen af A*, tages der udgangspunkt i tre metoder som befinder sig i \\texttt{Pathfinder} klassen, altså \\texttt{FindPath}, \\texttt{EstimateNeighbors} og \\texttt{TracePath}. Grunden til at vi udvælger disse metoder er fordi de er vigtige i forhold til hvordan programmet skal finde frem til den hurtigste vej i programmet. Derudover vil der også kigges på en metode som ligger i \\texttt{Vertex} klassen, der udregner kosten og estimeringen af den resterne kost.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\npublic static List<Road> FindPath(Node start, Node end)\n{\n  if (Vertices == null || start == null || end == null)\n    throw new ArgumentNullException();\n\n  InitLists();\n  SetStartEnd(start, end);\n  Start.Cost = 0;\n  Open.Add(Start);\n\n  Vertex current;\n  while (Open.LongCount() > 0)\n  {\n    current = Open.Min();\n    if (current == End)\n    {\n      return TracePath();\n    } \n    else\n    {\n      MoveToClosed(current);\n      EstimateNeighbors(current);\n    }\n  }\n  throw new Exception(\"There isn't any route\");\n}\n\\end{lstlisting}\n\\caption{FindPath metoden}\\label{FindPathCode}\n\\end{figure}\n\nDen første metode er \\texttt{FindPath}, der ses på figur \\ref{FindPathCode}, hvor der startes med at overskrive listerne \\texttt{Closed} og \\texttt{Open} med tomme lister gennem metoden \\texttt{InitLists}. \\texttt{SetStartEnd} metoden som køres derefter, finder de \\texttt{Vertex} der svarer til start og end noderne der bliver taget ind som parameter. I while løkken kigger den på \\texttt{Open} listen og tjekker om der er nogle \\texttt{Vertex} der ikke er evalueret endnu, hvis ikke kan ruten ikke findes og der kastes en exception. Inde i while loopet sættes det nuværende \\texttt{Vertex} til at være den mindste på \\texttt{Open} listen. Inde i \\texttt{Vertex} klassen, er interfacet \\texttt{IComparable} implementeret, således at \\texttt{Min()} metoden returnerer den \\texttt{Vertex} med den mindste \\texttt{Estimate}. Hvis vi er ved enden returneres \\texttt{Path} gennem metoden \\texttt{TracePath}, ellers bliver vi ved med at vurdere naboerne til den nuværende \\texttt{Vertex}, og sætter den nuværende over på \\texttt{Closed} listen, så den ikke bliver vurderet igen senere.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nprivate static void EstimateNeighbors(Vertex current)\n{\n  foreach (Edge edge in current.Edges)\n  {\n    Vertex neighbor = edge.VertexTo;\n    if (!Open.Contains(neighbor) && !Closed.Contains(neighbor)) \n    // Skip evaluated\n    {\n      neighbor.CalculateEstimate(current, edge, End, MaxSpeed); \n      Open.Add(neighbor);\n      if (neighbor.Cost <= current.Cost + edge.Cost) \n      neighbor.Previous = current;\n    }\n  }\n}\n\\end{lstlisting}\n\\caption{EstimateNeighbors metoden}\\label{EstimateNeighborsCode}\n\\end{figure}\n\nI \\texttt{EstimateNeighbors} metoden, der kan ses på figur \\ref{EstimateNeighborsCode}, kigger vi på naboerne, til den \\texttt{Vertex} der bliver givet gennem parameteret. Hvis naboen allerede er evalueret, skal vi ikke gøre det igen, ellers bliver de evalueret gennem metoden \\texttt{CalculateCostEstimate}, der ligger i selve \\texttt{Vertex} klassen. Sidst tjekkes der om naboens \\texttt{Cost} er bedre end den nuværende, hvor vi så vil sætte dens \\texttt{Previous} reference til at være den nuværende \\texttt{Vertex}, så vi senere kan finde vejen tilbage igen.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\npublic void CalculateCostEstimate(Vertex previous, Edge edge, \n                                  Vertex end, int maxSpeed)\n{\n   Cost = previous.Cost + edge.Cost;\n   double heuristic = MathExtension.Distance(this.Position, \n                                  end.Position) / maxSpeed;\n   Estimate = Cost + heuristic;\n}\n\\end{lstlisting}\n\\caption{CalculateCostEstimate metoden}\\label{CalculateCostEstimateCode}\n\\end{figure}\n\n\\texttt{CalculateCostEstimate} metoden, der er vist på figur \\ref{CalculateCostEstimateCode}, udregner hvad kosten er fra start til dette punkt, og estimere med heuristiken hvad den mindst mulige kost kunne være fra her til slut punktet.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nprivate static List<Road> TracePath()\n{\n   List<Road> roads = new List<Road>();\n   Vertex current = End;\n   while (current.Previous != null)              \n   { \n      roads.Add(current.Previous.Edges.Find(edge => \n                edge.VertexTo == current).Source);\n      current = current.Previous;\n   }\n   roads.Reverse();\n   return roads;\n}\n\\end{lstlisting}\n\\caption{TracePath metoden}\\label{TracePathCode}\n\\end{figure}\n\nSidst har vi på figur \\ref{TracePathCode} metoden \\texttt{TracePath}, der finder vejen tilbage, når algoritmen støder på slut punktet. Dette gøres ved at kigge på \\texttt{Previous} referencen for den nuværende \\texttt{Vertex}, og tilføje den vej der ligger mellem dem til en liste, ind til at \\texttt{Previous} er lig \\texttt{null}, hvilket vil sige at den er nået tilbage til start. Før ruten returneres bliver der kørt \\texttt{Reverse()} på listen, så den står i den rigtige rækkefølge.",
			"file": "sections/Implementation/PathFinder.tex",
			"file_size": 5150,
			"file_write_time": 131075599270411331,
			"settings":
			{
				"buffer_size": 5003,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "\\section{Kerne Funktionalitet}\\label{Kernefunktionalitet}\n\nFor at håndtere alle dele af programmet blev der implementeret en et styringscenter, som heri findes som klassen \\texttt{ToolController}. Formålet med denne fremgangsmåde skulle give bedre overblik over programmets mange metoder og give mulighed for let at håndtere fejl og ændringer i funktionaliteten. Klasserne i programmet er til dette formål håndteret objektorienteret og generelt nok til at fremgangsmåden kan fungere i praksis.\n\n%//////////////////////////////// ToolController ////////////////////////////////%\n\\subsection{ToolController}\n\\texttt{ToolController} klassen har til formål at forbinde de forskellige værktøjer så når brugeren f.eks. trykker på et af værktøjerne vil \\texttt{ToolControlleren} kalde de tilsvarende metoder til værktøjet. Samt at der kun at være valgt et værktøj af gangen. \\texttt{ToolController} er altså klassen som står for funktionerne som f.eks. \\texttt{AddNode()}, \\texttt{AddRoad()}, \\texttt{AddLightController()} osv.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\npublic ToolController(ToolStripItemCollection collection, \n                      Viewport viewport, Project project)\n{\n   Tools = collection;\n   Viewport = viewport;\n   Viewport.Input.MouseClick += ViewportClick;\n   Project = project;\n}\n\\end{lstlisting}\n\\caption{ToolController metoden}\\label{ToolControllerCode}\n\\end{figure}\n\nPå figur \\ref{ToolControllerCode} ses constructoren til \\texttt{ToolController}, der bliver kaldt via GUIMain som sender alle værktøjerne, nuværende viewport samt projekt. Herved har \\texttt{ToolController} alle elementerne til f.eks at tilføje en \\texttt{Node}.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nprivate void ViewportClick(object sender, MouseEventArgs args)\n{\n  if (ActiveTool != null && args.Button == MouseButtons.Left)\n  {\n    switch (ActiveTool.Name)\n    {\n      ...\n      case \"ToolAddNode\": Add(typeof(Node)); break;\n      case \"ToolLinkLight\": LinkLight(); break;\n      case \"ToolAddDestination\": Add(typeof(Destination)); break;\n      case \"ToolAddRoad\": AddRoad(Partitions.Shared); break;\n      case \"ToolPrimaryRoad\": AddRoad(Partitions.Primary); break;\n      case \"ToolEdit\": Edit(); break;\n      ...\n    }\n  }\n}\n\\end{lstlisting}\n\\caption{ViewportClick() metoden}\\label{ViewportClickCode}\n\\end{figure}\n\nDerudover bliver click eventen på \\texttt{Input} laget af \\texttt{Viewporten} i constructoren sat til at blive håndteret af metoden \\texttt{ViewportClick()}. \\texttt{ViewportClick()} der kan ses på figur \\ref{ViewportClickCode} tjekker hvilket værktøj der er aktivt og kalder den tilsvarende metode.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\npublic void ToggleTool(ToolStripButton clickedTool)\n{\n  if (clickedTool.Checked)\n  {\n    clickedTool.Checked = false;\n    ActiveTool = null;\n  }\n  else\n  {\n    foreach (ToolStripButton tool in \n      Tools.OfType<ToolStripButton>())\n      tool.Checked = false;\n    clickedTool.Checked = true;\n    ActiveTool = clickedTool;\n  }\n  StopConnection();\n}\n\\end{lstlisting}\n\\caption{ToggleTool metoden}\\label{ToggleToolCode}\n\\end{figure}\n\nFor at sikre at der ikke er “valgt” flere værktøjer på samme tid, kaldes metoden på figur \\ref{ToggleToolCode} \\texttt{ToogleTool}, hvergang et værktøj bliver trykket på. Metoden fravælger alle \\texttt{ToolStripButtons} i værktøjsListen, hvorefter det nuværende værktøj bliver sat til \\texttt{true} (active). Derefter bliver det valgte værktøj sat over i \\texttt{ActiveTool} variablen. Til sidst bliver \\texttt{StopConnection()} kaldt, som er en metode til at nulstille værktøjets handling, så hvis man f.eks. har valgt \\texttt{AddRoad} så vil \\texttt{StopConnection()} sikre at det næste klik på gitteret vil tilføje vejens startpunkt og ikke slutpunkt.\n\n\\vspace{5mm}\n\nKlassen indeholder som sagt alle værktøjerne og derfor indeholder klassen også en del metoder, derfor vil kun de mest væsentlige værktøjer blive beskrevet.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nprivate void Add(Type type)\n{\n  object obj = Viewport.GetObjByGridPos();\n  if (obj == null)\n  {\n    if (type == typeof(Node))\n    {\n      Project.Nodes.Add(new Node(Viewport.GridPos));\n      Viewport.Nodes.Refresh();\n    }\n    else if (type == typeof(Destination))\n    {\n      Project.Destinations.Add(new Destination(Viewport.GridPos,  \n                                   SelectedDestinationType));\n      Viewport.Entities.Refresh();\n    }\n    else if (type == typeof(LightController))\n    {\n      Project.LightControllers.Add(new \n        LightController(Viewport.GridPos));\n      Viewport.Entities.Refresh();\n    }\n  }\n  else if (obj is Node)\n  {\n    ((Node)obj).Type = NodeTypes.None;\n    Viewport.Nodes.Refresh();\n  }\n}\n\\end{lstlisting}\n\\caption{Add metoden}\\label{AddCode}\n\\end{figure}\n\n\\texttt{Add} metoden der ses på figur \\ref{AddCode} benyttes til flere værktøjer som f.eks. at tilføje en \\texttt{Node}, \\texttt{LightController} eller \\texttt{Destination}. Udfra typen som bliver sendt fra metodekaldet bestemmes hvilket objekt som skal tilføjes. Hvis den nuværende position i gitteret er en \\texttt{Node} bliver \\texttt{NodeTypen} sat til \\texttt{None} og gitteret vil blive opdateret med \\texttt{Refresh()}.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nprivate void SetNodeType(NodeTypes type)\n{\n  object obj = Viewport.GetObjByGridPos();\n  if (obj is Node)\n  {\n    if (type == NodeTypes.Light && \n        ((Node)obj).Type == NodeTypes.Light)\n      ((Node)obj).Green = !((Node)obj).Green;\n    else\n      ((Node)obj).Type = type;\n    Viewport.Nodes.Refresh();\n  }\n}\n\\end{lstlisting}\n\\caption{SetNodeType metoden}\\label{SetNodeTypeCode}\n\\end{figure}\n\n\\texttt{SetNodeType()} som er vist på \\ref{SetNodeTypeCode}, benyttes til at give den enkelte \\texttt{Node} en type som f.eks. \\texttt{Light}, \\texttt{Yield}, \\texttt{Home}, \\texttt{Parking} osv. Metoden modtager en \\texttt{NodeType} som bliver bestemt fra \\texttt{ViewportClick()}. Hvorefter den checker om objektet på den nuværende position i gitteret er en \\texttt{Node}. Hvis det er en \\texttt{Node} vil \\texttt{NodeTypen} blive sat til den modtaget type. Til sidst vil gitteret blive opdateret med \\texttt{Refresh()}.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nprivate void AddRoad(Partitions partition)\n{\n object obj = Viewport.GetObjByGridPos();\n if (obj != null && obj is Node)\n {\n    if (_firstNodeConnection)\n    {\n      _firstNode = (Node)obj;\n      _firstNodeConnection = false;\n      Viewport.HoverConnection = ((Node)obj).Position;\n    }\n    else\n    {\n      _firstNode.Roads.Add(new Road(_firstNode, (Node)obj, \n                               SelectedRoadType, partition));\n      if (Control.ModifierKeys == Keys.Shift)\n      {\n        _firstNode = (Node)obj;\n        Viewport.HoverConnection = ((Node)obj).Position;\n      }\n      else\n      {\n        _firstNodeConnection = true;\n        Viewport.HoverConnection = new Point(-1, -1);\n      }\n      Viewport.Connections.Refresh();\n    }\n  }\n}\n\\end{lstlisting}\n\\caption{AddRoad metoden}\\label{AddRoadCode}\n\\end{figure}\n\n\\texttt{AddRoad()} som kan ses på figur \\ref{AddRoadCode}, bruges til at tilføje en vej mellem 2 noder, derfor checkes der først om object på den nuværrende positon i gitteret er en node. Hvis det er en node vil der blive checket om \\texttt{\\_firstNodeConnection} er sket, altså om startpunktet til vejen er blevet valgt. Hvis \\texttt{\\_firstNodeConnection} er \\texttt{true}, betyder det at det ikke er sket, og noden på den nuværrendeposition i gitteret vil blive sat til \\texttt{\\_firstNode}, og \\texttt{\\_firstNodeConnection} vil blive \\texttt{false}. Det betyder at næste gang brugeren trykker på en node i gitteret vil programmet vide at \\texttt{\\_firstNode} er blevet sat, og derfor tilføjes der en vej mellem \\texttt{\\_firstNode} og noden på den nuværrende position i gitteret.\n\n\\vspace{5mm}\n\nHvis brugern holder \"Shift\" nede imens, vil programmet sætte \\texttt{\\_firstNode} til den nuværrende \\texttt{Node} efter at der er blevet tilføjet en vej, da den \\texttt{Node} vil være startpunktet for den næste vej. Det er en implementation som gør det nemmere og hurtigere for brugeren at tilføje veje. \n\n%//////////////////////////////// FileHandler ////////////////////////////////%\n\\subsection{FileHandler}\n\\texttt{FileHandleren} er sat op så at man har mulighed for at lave et ny projekt, åbne og gemme projektet. Der er blevet dannet tre metoder som håndtere de tre valg for brugeren, for at gøre det mest læsevenligt for dem der skal læse koden. \\texttt{FileHandler} gør sig brug af \\texttt{BinaryFormatter} for at gemme og åbne de forskellige objekter i binær form. Vi startede ud med at bruge \\texttt{XMLSerializer}, da vi lavede \\texttt{FileHandleren}. Vi stødte ind på nogle problemer da \\texttt{XMLSerializer} skulle læse to objekter som har en reference til hinanden, og det skabte en circular reference som var årsagen til vores program crashede på daværende tidspunkt. Ved denne fejl skiftede vi til \\texttt{BinaryFormatter}, da den er i stand til at håndtere en circular reference.\n\n\\vspace{5mm}\n\nMetoden \\texttt{NewProject} er meget simpel, den åbner et vindue med en \\texttt{TextBox}, der beder om et navn til det nye projekt. Hvis et navn blev indtastet vil der så blive oprettet et nyt projekt med det navn, og det vil erstatte \\texttt{CurrentProject} i \\texttt{GUIMain}.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nstatic public Project OpenProject()\n{\n  FileStream file = null;\n  try\n  {\n    OpenFileDialog fileOpen = new OpenFileDialog();\n    fileOpen.Filter = \"TSP Files|*.tsp\";\n    if (fileOpen.ShowDialog() == DialogResult.OK)\n    {\n      BinaryFormatter formatter = new BinaryFormatter();\n      file = new FileStream(fileOpen.FileName, FileMode.Open);\n      return (Project)formatter.Deserialize(file);\n    }\n    return null;\n  }\n  catch (Exception e)\n  {\n    MessageBox.Show(\"Error: \" + e.Message);\n    return null;\n  }\n  finally\n  {\n    if (file != null)\n    file.Close();\n  }\n}\n\\end{lstlisting}\n\\caption{OpenProject metoden}\\label{OpenProjectCode}\n\\end{figure}\n\nMetoden \\texttt{OpenProject}, der vises på figur \\ref{OpenProjectCode}, kan åbne et eksisterende projekt, når brugeren trykker på Open Project i menuen. Denne metode benytter sig af \\texttt{OpenFileDialog}, som ligger under \\texttt{System.Windows.Forms}. Koden benytter sig af try-catch-finally, hvor den går ind i try fasen og filtrerer alle andre fil-typer væk som ikke er en TSP fil (traffic simulation project), hvis TSP filen er valgt så vil metoden deserialisere og åbne det gemte projekt op. Sidst vil finally lukke filen, så andre kan komme til.\n\n\\begin{figure}[H]\n\\begin{lstlisting}\nstatic public void SaveProject(Project project)\n{ \n  FileStream file = null;\n  try\n  {\n    SaveFileDialog fileSave = new SaveFileDialog();\n    fileSave.AddExtension = true;\n    fileSave.DefaultExt = \"tsp\";\n    fileSave.Filter = \"TSP Files|*.tsp\";\n    if (fileSave.ShowDialog() == DialogResult.OK)\n    {\n      BinaryFormatter formatter = new BinaryFormatter();\n      file = new FileStream(fileSave.FileName, FileMode.Create);\n      formatter.Serialize(file, project);\n    }\n  }\n  catch (Exception e)\n  {\n    MessageBox.Show(\"Error: \" + e.Message);\n  }\n  finally\n  {\n    if (file != null)\n      file.Close();\n  }\n}\n\\end{lstlisting}\n\\caption{SaveProject metoden}\\label{SaveProjectCode}\n\\end{figure}\n\nPå figur \\ref{SaveProjectCode} ses metoden til at gemme et projekt. Igen benytter programmet af en try-catch-finally, hvor programmet i try fasen laver en ny instans af \\texttt{SaveFileDialog}, på den måde kan programmet gemme et projekt som man har arbejdet på. Programmet er sat op at den skal gemme projektet som tsp fil (traffic simulation project). Hvis det ikke lykkes, så vil den kaste en exception med fejlen der er sket. Finally fasen vil den så frigøre resourcerne igen.\n\n\\vspace{5mm}\n\n\\textbf{MANGLER: Noget om åbning og gemning af SimulationData}\n\n%//////////////////////////////// Simulation ////////////////////////////////%\n\\subsection{Simulation}\\label{SimulationClass}",
			"file": "sections/Implementation/Funktionelle.tex",
			"file_size": 11836,
			"file_write_time": 131075599270231320,
			"settings":
			{
				"buffer_size": 11933,
				"line_ending": "Windows"
			}
		},
		{
			"file": "sections/Implementation/Implementation.tex",
			"settings":
			{
				"buffer_size": 533,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Main.tex",
			"settings":
			{
				"buffer_size": 1098,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 490.0,
		"last_filter": "vmen",
		"selected_items":
		[
			[
				"vmen",
				"View: Toggle Menu"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"Package Control: ins",
				"Package Control: Install Package"
			],
			[
				"Package Control: inst",
				"Package Control: Install Package"
			],
			[
				"Package Control: insta",
				"Package Control: Install Package"
			],
			[
				"Package Control: instal",
				"Package Control: Install Package"
			],
			[
				"Package Control: Install",
				"Package Control: Install Package"
			],
			[
				"Package Control: Instal",
				"Package Control: Install Package"
			],
			[
				"syntaxc",
				"Set Syntax: C"
			],
			[
				"Package Control: in",
				"Package Control: Install Package"
			],
			[
				"syntax",
				"Set Syntax: C"
			]
		],
		"width": 549.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"latexmk -pdf -pv file.tex"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Programs/Git/P2-Simulering/LATEX",
		"/C/Programs/Git/P2-Simulering/LATEX/Pictures",
		"/C/Programs/Git/P2-Simulering/LATEX/sections",
		"/C/Programs/Git/P2-Simulering/LATEX/sections/Implementation",
		"/C/Programs/Git/P2-Simulering/LATEX/sections/Konklusion",
		"/C/Programs/Git/P2-Simulering/LATEX/sections/Metode",
		"/C/Programs/Git/P2-Simulering/LATEX/sections/ProblemetsRelevans",
		"/C/Programs/Git/P2-Simulering/LATEX/sections/Simulering",
		"/C/Programs/Git/P2-Simulering/LATEX/sections/Teknologianalyse",
		"/C/Programs/Git/P2-Simulering/LATEX/sections/Teori",
		"/C/Programs/Git/P2-Simulering/LATEX/setup"
	],
	"file_history":
	[
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/Indledning/Indledning.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/Interessentanalyse/Interessentanalyse.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/references.bib",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/ProblemetsRelevans/ProblemetsRelevans.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/sections.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/setup/preamble.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/setup/macros.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/Metode/Metode.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/Teknologianalyse/altrans.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/Teknologianalyse/altransWTF.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/Teknologianalyse/Teknologianalyse.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/Main.tex",
		"/C/Programs/Git/New-P2/P2-Simulering/LATEX/sections/Teori/Teori.tex",
		"/C/Users/Rasmus/AppData/Roaming/Sublime Text 3/Packages/User/LaTeXTools.sublime-settings",
		"/C/Program Files (x86)/MiKTeX 2.9/tex/latex/tools/.tex",
		"/C/Programs/GitHub_P2/P2-Simulering/LATEX/references.bib",
		"/C/Programs/GitHub_P2/P2-Simulering/LATEX/sections/teoriafsnit/teoriafsnit.tex",
		"/C/Users/Jacob Thomsen/AppData/Roaming/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/C/Programs/LaTeX Documents/LaTeX Document 2/assignment2.tex",
		"/C/Programs/Git/Rep B2-24/Program rapport/profileprogram.c",
		"/C/Programs/LaTeX Documents/LaTeX Document 1/document1.tex",
		"/C/Programs/C/Lektionone/helppage.c",
		"/C/Programs/C/Lektionone/eksamensopgavesuperliga.c",
		"/C/Programs/C/Lektionone/adresserfratxt.c",
		"/C/Programs/C/Lektionone/superliga-2014-2015.txt",
		"/C/Programs/C/Lektionone/adresser.txt",
		"/C/Programs/C/Lektionone/aflevering4.c",
		"/C/Programs/C/Lektionone/9.5.c",
		"/C/Programs/C/Lektionone/testaflevering2.c",
		"/C/Programs/C/Lektionone/opg2.7.c",
		"/C/Programs/C/Lektionone/12.2.c",
		"/C/Programs/C/Lektionone/deckofcards.c",
		"/C/Programs/C/Lektionone/testintro.c",
		"/C/Programs/C/Lektionone/contactinfo.txt",
		"/C/Programs/C/Lektionone/sammensetarrays.c",
		"/C/Programs/C/Lektionone/afleveringdonger.c",
		"/C/Programs/C/Lektionone/help.c",
		"/C/Users/Jacob Thomsen/AppData/Roaming/Sublime Text 3/Packages/Default/Preferences.sublime-settings",
		"/C/Programs/Git/Rep B2-24/sections/intro/intro.tex",
		"/C/Programs/Git/Rep B2-24/references.bib",
		"/C/Users/Jacob Thomsen/AppData/Roaming/Sublime Text 3/Packages/User/LaTeXTools.sublime-settings",
		"/C/Programs/C/Lektionone/examplemalloc.c",
		"/C/Programs/C/Lektionone/10.3.c",
		"/C/Programs/C/Lektionone/mad.c",
		"/C/Programs/C/Lektionone/exampleqsort.c",
		"/C/Programs/C/Lektionone/functions_root_2_slide.c",
		"/C/Programs/C/Lektionone/aflevering6.c",
		"/C/Programs/C/Lektionone/nyhms.c",
		"/C/Programs/C/Lektionone/opg6.6.c",
		"/C/Programs/C/Lektionone/test-prime.c",
		"/C/Programs/C/Lektionone/opg_267.c",
		"/C/Programs/C/Lektionone/3.1.c",
		"/C/Programs/C/Lektionone/primes.h",
		"/C/Programs/C/Lektionone/2.5.c",
		"/C/Programs/C/Lektionone/primes.c",
		"/C/Programs/C/Lektionone/2.3.c",
		"/C/Programs/C/Lektionone/prog88-2-c.c",
		"/C/Programs/C/Lektionone/sc88-1.c",
		"/C/Programs/C/Lektionone/prog88-2-b.c",
		"/C/Programs/C/Lektionone/prog88-2.c",
		"/C/Programs/C/Lektionone/2.1-3.c",
		"/C/Programs/C/Lektionone/2.1-2.c",
		"/C/Programs/C/Lektionone/2.1.c",
		"/C/Programs/C/Lektionone/side242prog2.c",
		"/C/Programs/C/Lektionone/side242prog1.c",
		"/C/Programs/C/Lektionone/sc2.3-1.c",
		"/C/Programs/C/Lektionone/pythagorean.c",
		"/C/Programs/C/Lektionone/opgave9.c",
		"/C/Programs/MinGW/msys/1.0/etc/profile",
		"/C/Programs/MinGW/msys/1.0/etc/fstab",
		"/C/MinGW/msys/1.0/etc/profile",
		"/C/MinGW/msys/1.0/etc/fstab"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"ViewportClick",
			"tsp",
			"Funktionelle",
			"a-stjerne",
			"Astjerne",
			"MISC",
			"60",
			"cite",
			"citep",
			"4",
			"gitre",
			"firkant",
			"firkanter",
			"MISC",
			"fight",
			"teams",
			"match_count",
			"league_table",
			".",
			"->",
			"had",
			"H",
			"BIG_NUMBER",
			":",
			"Spectators in total: ",
			"team_id",
			"team",
			"spectators",
			"football_data_array",
			"spectators",
			"i",
			"football_data_array[i].spectators",
			"team_spectator",
			"team_id",
			"current_high",
			"round_goal_amount",
			"total_lines",
			"number_of_lines",
			"spectators",
			"matchdata",
			"General",
			"Ret",
			"%c",
			"shelf",
			"Location",
			"Qualifiers",
			"ProductCode",
			"​",
			"uigytgu",
			"dickbutt"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 36,
						"regions":
						{
						},
						"selection":
						[
							[
								36,
								36
							]
						],
						"settings":
						{
							"default_dir": "C:\\Programs\\Git\\P2-Simulering\\LATEX\\sections\\Implementation",
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "sections/Implementation/Viewport.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6647,
						"regions":
						{
						},
						"selection":
						[
							[
								5758,
								5758
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1500.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "sections/Implementation/PathFinder.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5003,
						"regions":
						{
						},
						"selection":
						[
							[
								2476,
								2476
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1020.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "sections/Implementation/Funktionelle.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11933,
						"regions":
						{
						},
						"selection":
						[
							[
								4846,
								4850
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1740.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "sections/Implementation/Implementation.tex",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 533,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "Main.tex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1098,
						"regions":
						{
						},
						"selection":
						[
							[
								1083,
								1083
							]
						],
						"settings":
						{
							"syntax": "Packages/LaTeX/LaTeX.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 100.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "sublime_ux.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"with <stdio.h>"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 239.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
