\section{Diverse}\label{Diverse}
Dette afsnit dækker over klasserne der ikke ligger under en bred kategori af klasser.

\section{Project}
Project klassens formål er at holde på informationen om elementerne i vejnettet. Derudover holder Project klassen også på brugerens indstillinger for simuleringerne der udføres. Disse indstillinger er gemt i en instans af klassen SimulationSettings. Når Project klassen instansieres, tilføjer constructoren en Default type til RoadTypes, VehicleTypes og DestinationTypes, hvilket er listerne der gemme på alle typerne af deres slags. Default værdierne kan ikke slettes, da det ikke vil give mening for simuleringen at veje, køretøj og destinationer eksisterede uden en type, og programmet ville blive termineret. 

\begin{figure}[H]
\begin{lstlisting} 
public object Clone()
{
  MemoryStream memory = new MemoryStream();
  BinaryFormatter formatter = new BinaryFormatter();
  formatter.Serialize(memory, this);
  memory.Position = 0;
  return formatter.Deserialize(memory);
}
\end{lstlisting}
\caption{Project.cs}\label{Project}
\end{figure}

Project klassen implementerer interfacet ICloneable, der beder om en implementation af Clone(), der returnerer en kopi af en instans af et Project. Implementationen af Clone() funktionaliteten er vist på figur \ref{Project}, hvor instansen af Project bliver seraliseret vha. BinaryFormatter klassen, og derefter deserliseret samt returneret. Grunden til Clone funktionen er lave en 'deep copy' af projektet, da Simulation klassen har brug for en identisk men adskildt kopi, så køretøjerne i Primary og Secondary simuleringerne ikke kan se og holde for hinanden. En MemberwiseClone() som alle objekter har adgang til, laver kun en 'shallow copy', hvilket vil sige at noderne og vejene stadig ville være referencer til de samme som i det første projekt.

\section{SimulationSettings}
\begin{figure}[H]
\begin{lstlisting} 
// Defaults
public SimulationSettings()
{
  StepSize = 100;
  VehicleSpace = 2;
  IncommingRange = 10;
  PrimaryCarCount = 1000;
  PrimaryInbound = 100;
  PrimaryOutbound = 100;
  PrimaryToDestTime = 28800000; // 08:00
  PrimaryToHomeTime = 57600000; // 16:00
  PrimaryTimeSpread = 14400000; // 4h
  SecondaryCarCount = 1000;
  SecondaryInbound = 100;
  SecondaryOutbound = 100;
  SecondaryToDestTime = 28800000; // 08:00
  SecondaryToHomeTime = 57600000; // 16:00
  SecondaryTimeSpread = 14400000; // 4h
}
\end{lstlisting}
\caption{SimulationSettings}\label{SimulationSettings}
\end{figure}

SimulationSettings, som kan ses på figur \ref{SimulationSettings}, indeholder alle indstillingerne der bliver brugt i en simulering. Constructoren til klassen sætter variablerne til de definerede værdier. Værdierne kan justeres gennem brugerfladen GUIMenuSettingsSimulation. I brugerfladen kan værdierne tilgås gennem nogle NumericUpDown elementer, hvor minimum og maximum er sat for at kontrollerer hvordan simuleringen kan indstilles. På tabel \ref{SimulationLimits} kan begrænsningerne ses. Yderligere er der også regler brugeren skal overholde når indstillingerne skal sættes. Inbound og Outbound skal være lavere end VehicleCount, og TimeSpread må ikke gøre det muligt at køretøjer kan starte deres rejser uden for tidsrummet mellem 0 og 86400000 millisekunder. Der er lavet en brugerflade, der kan tilgås ved at trykke på en Info knap, som beskriver hvad variablerne betyder, da navnene muligvis kunne blive misforstået.

\begin{table}[]
\centering
\begin{tabular}{|l|l|l|}
\hline
Variable       & Minimum & Maximum  \\ \hline
StepSize       & 10      & 100      \\ \hline
VehicleSpace   & 0       & 100      \\ \hline
IncommingRange & 0       & 100      \\ \hline
CarCount       & 0       & 10000    \\ \hline
Inbound        & 0       & 10000    \\ \hline
Outbound       & 0       & 10000    \\ \hline
ToDestTime     & 0       & 86400000 \\ \hline
ToHomeTime     & 0       & 86400000 \\ \hline
TimeSpread     & 0       & 86400000 \\ \hline
\caption{Begrænsninger for simulering indstillingerne}
\label{SimulationLimits}
\end{tabular}
\end{table}

\subsection{Data}
SimulationData, er en klasse, se \ref{SimulatonDataClass}, som modtager to lister fra VehicleData og derudover tager den imod information fra Project og Datetime. Konstruktoren SimulationData læser disse data ind til de forskelige typer i klassen. Hvis ToString metoden bliver kaldt, så retuneres Project.name og en DateTime type.


VehicleData for den enkelte vehicle lagt over i to liste, PrimaryData og SecondaryData. VehicleData består ikke af nogle større funktioner og derfor vil der ikke være nogle dybbere forklaring dertil. Den består af nogle typer der læser data fra PointD klassen og VehicleType.

\subsection{MathExtension}
MathExtension er en klasse der er lavet for at håndtere udregningerne fra \texttt{Point} til \texttt{Point}, fra \texttt{PointD} til \texttt{PointD} samt en kort kovertering af km/h til m/ms. Der gøres bruge af klasser fra \texttt{Math} bibliotek. Måden vi udregner km/h til m/ms, er ved at tage kt/h og dividere med 3600(60*60) Se udregning \ref{ConvertKthToMms}. Vi benytter os af afstandsformlen i MathExtension, hvor vi beregner afstanden mellem to noder via deres koordinater \ref{AfstandsFormel}. Disse udregninger anvendes bl.a i Vector2D klassen.

\begin{equation} \label{ConvertKthToMms}
kt/h / 3600
\end{equation}

\begin{equation} \label{AfstandsFormel}
\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{equation}

\subsection{Vector2D}
Vector2D klassen anvendes til at opsætte de metoder som gør det muligt at bl.a. vehicles kan udregne hvor hen de skal bevæge sig i simuleringen. Metoderne er for det meste til at indlæse koordinter på gridded i simuleringen til anvendelse når simuleringen kører, se \ref{MathExtensionClass}. I denne klasse har vi tre metoder, hvor i den første metode \texttt{Scale()} ganger vi vektoren op med en input parameter der bliver bestemt af brugeren. I \texttt{ToUnit()} bliver vores x og y divideret med størrelsen af vektoren. \texttt{FromRoad()} metoden beregner vektoren der tager udgangspunkt i vejenes position. Ved vektor.X, der trækker man vejens slut position fra start position og ligger ind i variablen \texttt{vector.X}. Samme gør man ved \texttt{vector.Y}, derefter vil metoden returnere vektoren.

\begin{figure}[H]
\begin{lstlisting}
class Vector2D
{
   public double X { get; set; }
   public double Y { get; set; }
   public double Length
   {
      get { return MathExtension.Distance(new PointD(0, 0), new PointD(X, Y)); }
   }
   public void Scale(double scalar)
   {
      X *= scalar;
      Y *= scalar;
   }
   public void ToUnit()
   {
      double magnitude = Length;
      X /= magnitude;
      Y /= magnitude;
   }
      public static Vector2D FromRoad(Road road)
      {
         Vector2D vector = new Vector2D();
         vector.X = road.To.Position.X - road.From.Position.X;
         vector.Y = road.To.Position.Y - road.From.Position.Y;
         return vector;
      }
   }
}
\end{lstlisting}
\caption{Vector2D Klasse}\label{MathExtensionClass}
\end{figure}

ref til figur