\section{Diverse}\label{Diverse}

\section{Project}

Project klassen har til formål at sætte de forskellige types klasser op i lister, mens Project (string name) samtidig sætter default values når man laver en ny RoadType, DestinationType eller VehicleType i programmet, hver gang der bliver "addet" noget nyt til de forskellige lister under Types. Project Clones gør det muligt at gemme det man har lavet i en ny fil, som så kan bruges senere såfremt det skal sættes ind andre steder i programmet ved eksempelvis at copy-paste det.

\begin{figure}[H]
\begin{lstlisting} 

{ 
    [Serializable]
    public class Project : ICloneable
    {
        public string Name;
        public List<Node> Nodes = new List<Node>();
        public List<Destination> Destinations = new List<Destination>();
        public List<LightController> LightControllers = new List<LightController>();
        public List<RoadType> RoadTypes = new List<RoadType>();
        public List<DestinationType> DestinationTypes = new List<DestinationType>();
        public List<VehicleType> VehicleTypes = new List<VehicleType>();
        public List<SimulationData> Simulations = new List<SimulationData>();
        public SimulationSettings Settings = new SimulationSettings();
        
        public Project(string name)
        {
            Name = name;
            RoadTypes.Add(new RoadType("Default", 50));
            DestinationTypes.Add(new DestinationType("Default", Color.LightSlateGray) { Distribution = 100 });
            VehicleTypes.Add(new VehicleType("Default", 130, 5, 5, Color.LightSlateGray) { Distribution = 100 });
        }

        public object Clone()
        {
            MemoryStream memory = new MemoryStream();
            BinaryFormatter formatter = new BinaryFormatter();
            formatter.Serialize(memory, this);
            memory.Position = 0;
            return formatter.Deserialize(memory);
        }
    }
}
\end{lstlisting}
\caption{Project.cs}\label{Project}
\end{figure}


\section{SimulationSettings}

SimulationSettings sætter defaultværdierne til de forskellige variabler, og giver brugeren muligheden for at ændre dem og gemme dem med nye værdier i stedet for de predefineret values, skulle man fortryde de selvdefineret values der er blevet sat, kan man altid vælge SetDefault values, ændre ens settings tilbage til de originale default values.

\begin{figure}[H]
\begin{lstlisting} 

{
    [Serializable]
    public class SimulationSettings
    {
        // Shared
        public int StepSize { get; set; }
        public int VehicleSpace { get; set; }
        public int IncommingRange { get; set; }

        // Primary
        public int PrimaryCarCount { get; set; }
        public int PrimaryInbound { get; set; }
        public int PrimaryOutbound { get; set; }
        public int PrimaryToDestTime { get; set; }
        public int PrimaryToHomeTime { get; set; }
        public int PrimaryTimeSpread { get; set; }

        // Secondary
        public int SecondaryCarCount { get; set; }
        public int SecondaryInbound { get; set; }
        public int SecondaryOutbound { get; set; }
        public int SecondaryToDestTime { get; set; }
        public int SecondaryToHomeTime { get; set; }
        public int SecondaryTimeSpread { get; set; }

        // Defaults
        public SimulationSettings()
        {
            StepSize = 100;
            VehicleSpace = 2;
            IncommingRange = 10;
            PrimaryCarCount = 1000;
            PrimaryInbound = 100;
            PrimaryOutbound = 100;
            PrimaryToDestTime = 28800000; // 08:00
            PrimaryToHomeTime = 57600000; // 16:00
            PrimaryTimeSpread = 14400000; // 4h
            SecondaryCarCount = 1000;
            SecondaryInbound = 100;
            SecondaryOutbound = 100;
            SecondaryToDestTime = 28800000; // 08:00
            SecondaryToHomeTime = 57600000; // 16:00
            SecondaryTimeSpread = 14400000; // 4h
        }
    }
}
\end{lstlisting}
\caption{SimulationSettings}\label{SimulationSettings}
\end{figure}

\subsection{Data}
SimulationData, er en klasse, se \ref{SimulatonDataClass}, som modtager to lister fra VehicleData og derudover tager den imod information fra Project og Datetime. Konstruktoren SimulationData læser disse data ind til de forskelige typer i klassen. Hvis ToString metoden bliver kaldt, så retuneres Project.name og en DateTime type.

\begin{figure}[H]
\begin{lstlisting}
public class SimulationData
{
     public Project Project { get; private set; }
     public List<VehicleData> PrimaryData { get; private set; }
     public List<VehicleData> SecondaryData { get; private set; }
     public DateTime Date { get; private set; }
     public string Filename
     {
        get { return Project.Name + "_" + Date.ToString("dd") + "-" + Date.ToString("MM") + "-" + 
              Date.ToString("yy") + "_" + Date.ToString("HH") + Date.ToString("mm") + ".sim"; }
     }
        
     public SimulationData(Project project, List<VehicleData> primary, List<VehicleData> secondary)
     {
        Project = project;
        PrimaryData = primary;
        SecondaryData = secondary;
        Date = DateTime.Now;
     }

     public override string ToString()
     {
       return Project.Name + " " + Date;
     }
}
\end{lstlisting}
\caption{SimulationData Klasse} \label{SimulatonDataClass}
\end{figure}

VehicleData for den enkelte vehicle lagt over i to liste, PrimaryData og SecondaryData. VehicleData består ikke af nogle større funktioner og derfor vil der ikke være nogle dybbere forklaring dertil. Den består af nogle typer der læser data fra PointD klassen og VehicleType.

\subsection{MathExtension}
MathExtension er en klasse der er lavet for at håndtere udregningerne fra \texttt{Point} til \texttt{Point}, fra \texttt{PointD} til \texttt{PointD} samt en kort kovertering af km/h til m/ms. Der gøres bruge af klasser fra \texttt{Math} bibliotek. Måden vi udregner km/h til m/ms, er ved at tage kt/h og dividere med 3600(60*60) Se udregning \ref{ConvertKthToMms}. Vi benytter os af afstandsformlen i MathExtension, hvor vi beregner afstanden mellem to noder via deres koordinater \ref{AfstandsFormel}. Disse udregninger anvendes bl.a i Vector2D klassen.

\begin{equation} \label{ConvertKthToMms}
kt/h / 3600
\end{equation}

\begin{equation} \label{AfstandsFormel}
\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{equation}

\subsection{Vector2D}
Vector2D klassen anvendes til at opsætte de metoder som gør det muligt at bl.a. vehicles kan udregne hvor hen de skal bevæge sig i simuleringen. Metoderne er for det meste til at indlæse koordinter på gridded i simuleringen til anvendelse når simuleringen kører, se \ref{MathExtensionClass}. I denne klasse har vi tre metoder, hvor i den første metode \texttt{Scale()} ganger vi vektoren op med en input parameter der bliver bestemt af brugeren. I \texttt{ToUnit()} bliver vores x og y divideret med størrelsen af vektoren. \texttt{FromRoad()} metoden beregner vektoren der tager udgangspunkt i vejenes position. Ved vektor.X, der trækker man vejens slut position fra start position og ligger ind i variablen \texttt{vector.X}. Samme gør man ved \texttt{vector.Y}, derefter vil metoden returnere vektoren.

\begin{figure}[H]
\begin{lstlisting}
class Vector2D
{
   public double X { get; set; }
   public double Y { get; set; }
   public double Length
   {
      get { return MathExtension.Distance(new PointD(0, 0), new PointD(X, Y)); }
   }
   public void Scale(double scalar)
   {
      X *= scalar;
      Y *= scalar;
   }
   public void ToUnit()
   {
      double magnitude = Length;
      X /= magnitude;
      Y /= magnitude;
   }
      public static Vector2D FromRoad(Road road)
      {
         Vector2D vector = new Vector2D();
         vector.X = road.To.Position.X - road.From.Position.X;
         vector.Y = road.To.Position.Y - road.From.Position.Y;
         return vector;
      }
   }
}
\end{lstlisting}
\caption{Vector2D Klasse}\label{MathExtensionClass}
\end{figure}

ref til figur