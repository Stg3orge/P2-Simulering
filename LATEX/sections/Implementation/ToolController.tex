\section{ToolController}\label{ToolController}

ToolController klassen har til formål at forbinde de forskellige “værktøjer” så når brugeren f.eks. trykker på et af værktøjerne vil ToolControlleren kalde de tilsvarende metoder til værktøjet. Samt at der kun at være valgt et værktøj af gangen. ToolController er altså klassen som står for funktionerne som f.eks. AddNode, AddRoad, AddLightController osv.

\vspace{5mm}

ToolControllerens constructor bliver kaldt via GUIMAIN som sender alle værktøjerne, nuværende viewport samt projekt. Herved har ToolController alle elementerne til f.eks at tilføje en Node.

\begin{figure}[H]
\begin{lstlisting}
public ToolController(ToolStripItemCollection collection, Viewport viewport, Project project)
        {
            Tools = collection;
            Viewport = viewport;
            Viewport.Input.MouseClick += ViewportClick;
            Project = project;
        }
\end{lstlisting}
\caption{ToolController metoden}\label{ToolControllerCode}
\end{figure}

\vspace{5mm}

Constructoren kører desuden metoden ViewportClick() som indeholder en switch som kører den tilsvarende metode til det valgte værktøj, ud fra hvilket string navn det valgte værktøj navn har.

\begin{figure}[H]
\begin{lstlisting}
        private void ViewportClick(object sender, MouseEventArgs args)
        {
            if (ActiveTool != null && args.Button == MouseButtons.Left)
            {
                switch (ActiveTool.Name)
                {
                    case "ToolAddNode": Add(typeof(Node)); break;
                    case "ToolSetNodeLight": SetNodeType(NodeTypes.Light); break;
                    case "ToolSetNodeYield": SetNodeType(NodeTypes.Yield); break;
                    case "ToolSetNodeHome": SetNodeType(NodeTypes.Home); break;
                    case "ToolSetNodeParking": SetNodeType(NodeTypes.Parking); break;
                    case "ToolSetNodeInbound": SetNodeType(NodeTypes.Inbound); break;
                    case "ToolSetNodeOutbound": SetNodeType(NodeTypes.Outbound); break;
                    case "ToolAddLightController": Add(typeof(LightController)); break;
                    case "ToolLinkLight": LinkLight(); break;
                    case "ToolAddDestination": Add(typeof(Destination)); break;
                    case "ToolAddRoad": AddRoad(Partitions.Shared); break;
                    case "ToolPrimaryRoad": AddRoad(Partitions.Primary); break;
                    case "ToolSecondaryRoad": AddRoad(Partitions.Secondary); break;
                    case "ToolEdit": Edit(); break;
                    case "ToolRemove": Remove(); break;
                    case "ToolMoveObject": Move(); break;
                    default: break;
                }
            }
        }
\end{lstlisting}
\caption{ViewportClick metoden}\label{ViewportClickCode}
\end{figure}

\vspace{5mm}

For at sikre at der ikke er “valgt” flere værktøjer på samme tid, kaldes metoden ToogleTool hvergang et værktøj bliver trykket på. Metoden fravælger alle ToolStripButtons i værktøjsListen, hvorefter det nuværende værktøj bliver sat til ture(active). Til sidst bliver det valgte værktøj sat over i ActiveTool variablen. Til sidst bliver StopConnection() kaldt, som er en metode til at nulstiller værktøjets handling, så hvis man f.eks. har valgt “AddRoad” så vil StopConnection() sikre at det næste klik på griddet vil tilføje vejens startpunkt og ikke slutpunkt.

\begin{figure}[H]
\begin{lstlisting}
        public void ToggleTool(ToolStripButton clickedTool)
        {
            if (clickedTool.Checked)
            {
                clickedTool.Checked = false;
                ActiveTool = null;
            }
            else
            {
                foreach (ToolStripButton tool in Tools.OfType<ToolStripButton>())
                    tool.Checked = false;
                clickedTool.Checked = true;
                ActiveTool = clickedTool;
            }
            StopConnection();
        }
\end{lstlisting}
\caption{ToggleTool metoden}\label{ToggleToolCode}
\end{figure}

\vspace{5mm}

Klassen indeholder som sagt alle værktøjerne og derfor indeholder klassen også en del metoder, derfor vil kun de mest væsentlige værktøjer blive beskrevet.

\vspace{5mm}

\textbf{Add:} \newline
Add() benyttes til flere værktøjer som f.eks. at tilføje node, lightcontroller eller destination. Udfra typen som bliver sendt fra metodekaldet bestemmes hvilket objekt som skal tilføjes. Hvis den nuværende position i griddet er en Node bliver NodeTypen sat til “None” og griddet vil blive opdateret med Refresh(). 

\begin{figure}[H]
\begin{lstlisting}
private void Add(Type type)
        {
            object obj = Viewport.GetObjByGridPos();
            if (obj == null)
            {
                if (type == typeof(Node))
                {
                    Project.Nodes.Add(new Node(Viewport.GridPos));
                    Viewport.Nodes.Refresh();
                }
                else if (type == typeof(Destination))
                {
                    Project.Destinations.Add(new Destination(Viewport.GridPos,  
		                            SelectedDestinationType));
                    Viewport.Entities.Refresh();
                }
                else if (type == typeof(LightController))
                {
                    Project.LightControllers.Add(new LightController(Viewport.GridPos));
                    Viewport.Entities.Refresh();
                }
            }
            else if (obj is Node)
            {
                ((Node)obj).Type = NodeTypes.None;
                Viewport.Nodes.Refresh();
            }
\end{lstlisting}
\caption{Add metoden}\label{AddCode}
\end{figure}

\vspace{5mm}

\textbf{SetNodeType:} \newline
SetNodeType() benyttes til at give den enkelte Node en type som f.eks. Light, Yield, Home, Parking osv. Metoden modtager en NodeType som bliver bestemt fra ViewportClick(). Hvorefter den checker om objektet på den nuværende position i griddet er en Node. Hvis det er en Node vil NodeTypen blive sat til den modtaget type. Til sidst vil griddet blive opdateret med Refresh().

\begin{figure}[H]
\begin{lstlisting}
        private void SetNodeType(NodeTypes type)
        {
            object obj = Viewport.GetObjByGridPos();
            if (obj is Node)
            {
                if (type == NodeTypes.Light && ((Node)obj).Type == NodeTypes.Light)
                    ((Node)obj).Green = !((Node)obj).Green;
                else
                    ((Node)obj).Type = type;

                Viewport.Nodes.Refresh();
            }
        }
\end{lstlisting}
\caption{SetNodeType metoden}\label{SetNodeTypeCode}
\end{figure}

\vspace{5mm}


\textbf{AddRoad:} \newline
AddRoad() bruges til at tilføje en vej mellem 2 noder, derfor checkes der først om object på den nuværrende positon i griddet er en node. Hvis det er en node vil der blive checket om \_firstNodeConnection er sket, altså om startpunktet til vejen er blevet valgt. Hvis \_firstNodeConnection er ture, betyder det at det ikke er sket, og noden på den nuværrendeposition i griddet vil blive sat til \_firstNode, og \_firstNodeConnection vil blive false. Det betyder at næste gang brugeren trykker på en node i griddet vil programmet vide at \_firstNode er blevet sat, og derfor tilføjes der en vej mellem \_firstNode og noden på den nuværrende position i griddet.

Hvis brugern holder "Shift" nede imens, vil programmet sætte \_firstNode til den nuværrende node efter at der er blevet tilføjet en vej, da den node vil være startpunktet for den næste vej. Det er en implementation som gør det nemmere og hurtigere for brugeren at tilføje veje. 


\begin{figure}[H]
\begin{lstlisting}
        private void AddRoad(Partitions partition)
        {
            object obj = Viewport.GetObjByGridPos();
            if (obj != null && obj is Node)
            {
                if (_firstNodeConnection)
                {
                    _firstNode = (Node)obj;
                    _firstNodeConnection = false;
                    Viewport.HoverConnection = ((Node)obj).Position;
                }
                else
                {
                    _firstNode.Roads.Add(new Road(_firstNode, (Node)obj, SelectedRoadType, partition));
                    if (Control.ModifierKeys == Keys.Shift)
                    {
                        _firstNode = (Node)obj;
                        Viewport.HoverConnection = ((Node)obj).Position;
                    }
                    else
                    {
                        _firstNodeConnection = true;
                        Viewport.HoverConnection = new Point(-1, -1);
                    }
                    Viewport.Connections.Refresh();
                }
            }
        }
\end{lstlisting}
\caption{AddRoad metoden}\label{AddRoadCode}
\end{figure}



















