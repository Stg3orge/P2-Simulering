\chapter{Implementation}\label{Implementation}

I dette afsnit vil vi beskrive implementeringen af de forskellige dele af gruppens løsningsforslag. Efter vi havde kigget på problemanalysen, problemformuleringen og de succeskritiere vi havde udvundet fra dem, mente vi at det var vigtigt at planlægge hvad vores program skulle bestå af. Med dette menes det at lave en strukturert plan over hvilke klasser der skal bruges og vilke metoder disse klasser skal benytte sig af for at kunne give os den løsning vi mener besvare problemformuleringen og retter op på de problemer vi fandt fra problemanalyse. Til dette formål blev der opstillet et klasse diagram der beskriver disse forskellige klasser og sætter dem op i et hieraki således. Klasse diagramet figur(ikke indsat endnu) kan ses herunder:

{indsæt klasse diagram}

Farvekoden for klassediagrammet er som følgende:

\begin{enumerate}
\item Grøn: Prioriteret
\item Gul: Sekundært
\item Rød: Ikke prioriteret til prototype
\end{enumerate}

Vi har såvidt muligt forsøgt at opstille et klassediagram for alle de forskellige funktioner vi godt kunne tænke os af den "Ideelle" prototype indeholder. Da vi har en begrænset mængde tid så har vi været nød til at prioritere hvilke funktioner vi i gruppen anser for at være primære og som der skal være fokus på (Grønt) og hvilke som kan arbejdes på hvis der er tid bagefter eller som kan arbejdes på efter deadline. Som det ses på klasse diagrammet har vi valgt at fokuserer på 3 græne af programmet. Vehicle, Road og Trafic Components. Vi mener at disse tre græne af programmet kan give os en funktionel prototype og indeholder de nøglekomponenter som programmet skal bruge for at kunne simulerer trafik i en dynamisk kontekst.

Vi vil derfor i dette afsnit fokuserer på at dokumentere de mest væsentlige klasser og metoder i programmet og diskuterer for hvorfor netop disse dele af programmet er essentielle

\subsection{Road Klassen}
Road klassen indeholder de metoder der skal anvendes for at brugeren kan opstille veje i programmet.
\begin{lstlisting}
public class Road
    {
        public Node From { get; set; }
        public Node Destination { get; set; }
        public RoadType Type { get; set; }
        public enum RoadDifferentiation {Primary, Secondary, Shared };
        public double Length { get { return GetLength(); } }
        public double Cost { get; set; }

        private Road(){} // Serialize
        public Road(Node from, Node destination, RoadType type)
        {
            From = from;
            Destination = destination;
            Type = type;
        }

        private double GetLength()
        {
            return (Math.Sqrt(Math.Pow(Math.Abs(From.Position.X - Destination.Position.X), 2) 
                            + Math.Pow(Math.Abs(From.Position.Y - Destination.Position.Y), 2)));
        }
    }
\end{lstlisting}
Road klassen tager imod en instans af RoadType som brugeren selv har defineret via RoadType klassen. På denne måde har brugeren kontrol over hvilken type vej der tale om og hvordan vejen opfører sig i programmet, f.eks. om det er en motorvej. Vejene er programmeret således at brugeren selv kan opstille forskellige kryds, rundkørsler eller andre avanceret afkørsels baner. RoadType er en seperat klasse hvori brugeren give et "Name" og en "Speed", på denne måde definere brugeren selv hvilke typer veje der optræder i deres simulation.

\subsection{Vehicle klassen}
Vores vehicle klasse er ikke meget anderledes fra vores Road klasse. Denne klasse, meget ligesom Road klassen, er implementeret således at brugeren kan definerer deres egne vehicles til deres simulering.
\begin{lstlisting}
 class Vehicle
    {
        public Node Home;
        public Destination Destination;
        public Point Position;
        public VehicleType Type;
        public int TravelTime;
        public int HomeTime;

        public Vehicle(Node home, Destination destination, VehicleType type, int travelTime, int homeTime)
        {
            Home = home;
            Destination = destination;
            Position = Home.Position;
            Type = type;
            TravelTime = travelTime;
            HomeTime = homeTime;
        }
    }
\end{lstlisting}
Igen bliver der brugt en klasse kaldt VehicleType. Igen bruges denne klasse til at brugeren kan oprette deres egne VehicleTypes, så vis brugeren skal bruge en bus, en varevogn eller noget helt tredje til deres simulering, så har de muligheden for at definere disse og beskrive deres opførsel. I vores program har brugeren mulighed for at definere følgende: Name, MaxSpeed, Acceleration, Deceleration, Color (En instance af endnu en klasse) og Distribution. Destribution er en procentsats som brugeren kan sætte for at udtrykke hvor mange procent af biler i deres simulering der skal være af denne VehicleType.

\subsection{Destination}
Destination klassen i vores program er et punkt hvorpå bilerne vil søge henimod. Dette er ikke det punkt hvor bilerne stopper, til dette formål anvendes der en Node som er angivet til at være til parkering i nærheden af en destination. Destination klassen består af et kald af DestionationType klassen, dette er, ligesom med Vehicle og Road klasserne, en klasse der bruges til at brugerdefinere forskellige typer af destinations med forskellige parametre. Derudover retunerer en Destionation også sine kordinater på det grid brugeren tegner deres simuleringsmiljø på.

\subsection{Node}
I vores program anvender vi et grid hvorpå brugeren indsætter noder der udgør de forskellige vejnet der bliver oprettet. Disse noder kan have forskellige funktioner. Dette er gjort således at processen i at oprette vejnet er relativt simple. Et simpelt eksempel ville være at brugeren indsætte to noder, den første node hvor brugeren ønsker biler køre fra, den næste er en Parking node tæt på de bilers Destination. Således kan et meget simpelt vejnet opstille. Men det er også muligt for brugeren at opstille meget mere komplekse vejnet med lyskryds.

\subsection{Project}
Ligesom i mange andre programmer, så er det tænkeligt at brugeren vil arbejde med forskellige projekter og gerne vil gemme deres arbejde i en fil. Til dette formål har vi vores Project class som gør det muligt for brugeren at oprette flere forskellige projekter.

\begin{figure}[H]
\begin{lstlisting}
public class Project : ICloneable
    {
        public string Name;
        public List<Node> Nodes = new List<Node>();
        public List<Destination> Destinations = new List<Destination>();
        public List<LightController> LightControllers = new List<LightController>();
        public List<RoadType> RoadTypes = new List<RoadType>();
        public List<DestinationType> DestinationTypes = new List<DestinationType>();
        public List<VehicleType> VehicleTypes = new List<VehicleType>();
        public List<SimulationData> Simulations = new List<SimulationData>();
        public SimulationSettings Settings = new SimulationSettings();
        
        public Project(string name)
        {
            Name = name;
            RoadTypes.Add(new RoadType("Default", 50));
            DestinationTypes.Add(new DestinationType("Default", Color.LightSlateGray) { Distribution = 100 });
            VehicleTypes.Add(new VehicleType("Default", 130, 5, 5, Color.LightSlateGray) { Distribution = 100 });
        }

        public object Clone()
        {
            return DeepCopy(this);
        }

        // http://www.codeproject.com/Articles/38270/Deep-copy-of-objects-in-C
        private static object DeepCopy(object obj)
        {
            if (obj == null)
                return null;
            Type type = obj.GetType();

            if (obj is string || type.IsValueType)
                return obj;
            else if (type.IsArray)
            {
                Type elementType = Type.GetType(type.FullName.Replace("[]", string.Empty));
                var array = obj as Array;
                Array copied = Array.CreateInstance(elementType, array.Length);
                for (int i = 0; i < array.Length; i++)
                    copied.SetValue(DeepCopy(array.GetValue(i)), i);
                return Convert.ChangeType(copied, obj.GetType());
            }
            else if (type.IsClass)
            {
                object toret = Activator.CreateInstance(obj.GetType());
                FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                foreach (FieldInfo field in fields)
                {
                    object fieldValue = field.GetValue(obj);
                    if (fieldValue == null)
                        continue;
                    field.SetValue(toret, DeepCopy(fieldValue));
                }
                return toret;
            }
            else throw new ArgumentException("Unknown Type");
        }
    }
\end{lstlisting}
\caption{Project Klassen}\label{projectClass}
\end{figure}
Når et nyt projekt bliver oprettet af brugeren, så istanceres der nogle default instancer af de før nævnte klasser. Dvs. at programmet har en Default RoadType, DestinationType, og VehicleType.
(indsæt forklaring af deepcopy?)

\subsection{Lightcontroller}
LightController klassen er den del af programmet hvori brugeren kan indstille på deres trafiklys's noders opførsel.

\begin{figure}{H}
\begin{lstlisting}
 public class LightController : Entity, IPositionable
    {
        public List<Node> Lights { get; private set; }
        public int FirstTime { get; set; }
        public int SecondTime { get; set; }
        private int _current;
        private int _counter = 0;
        
        public LightController(Point position) : base(position)
        {
            Lights = new List<Node>();
            FirstTime = 10;
            SecondTime = 10;
            _current = FirstTime;
            
        }

        public override string ToString()
        {
            return "(" + Position.X + "," + Position.Y + ") " + FirstTime + "/" + SecondTime;
        }
        public void Update(int ms)
        {
            _counter += ms;
            if (_counter > _current)
            {
                if (_current == FirstTime)
                    _current = SecondTime;
                else
                    _current = FirstTime;
                ToggleLights();
                _counter = 0;
            }
        }
        private void ToggleLights()
        {
            foreach (Node light in Lights)
                light.Green = !light.Green;
        }
    }
\end{lstlisting}
\caption{LightController Klasse}\label{LightControllerClass}
\end{figure}

LightControllerens funktioner er at skrifte trafiklys fra rød til grøn og tilbage igen. Dette er muligt at gøre ved to seperate intervaller sådan at trafiklysene skifter efter forskellige mængder tid. Dette valg blev truffet efter det blev iagtaget at denne samme opførsel ses også på trafikkryds rundt omkring i Aalborg. Dette er idelt hvis brugeren prøver at simulerer et trafikryds hvor den ene vej er  mere anvendt en den anden, f.eks. En vej der leder ind i byen fra en motorvej der krydser med en vej der leder ind til mindre boligkompleks.
